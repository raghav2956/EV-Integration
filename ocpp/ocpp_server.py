from datetime import datetime
import logging
import websockets
import asyncio
from ocpp.routing import on
from ocpp.v16 import ChargePoint as cp
from ocpp.v16.enums import Action, RegistrationStatus, ConfigurationStatus, ChargingProfilePurposeType, ChargingProfileKindType, RecurrencyKind
from ocpp.v16 import call_result
from ocpp.v16 import datatypes


class MyChargePoint(cp):
    @on(Action.BootNotification)
    async def on_boot_notification(self, charge_point_vendor, charge_point_model, **kwargs):
        return call_result.BootNotificationPayload(
            current_time=datetime.now().isoformat(),
            interval=10,
            status=RegistrationStatus.accepted
        )
    
    @on(Action.MeterValues)
    async def on_meter_values(
        self, connector_id: int, transaction_id: int, meter_value: list, **kwargs
    ):
        logging.info(f"MeterValues received: Connector ID: {connector_id}, "
                     f"Transaction ID: {transaction_id}, Meter Values: {meter_value}")
        
        # Here, you would typically process and store the meter values, e.g., update a database.
        
        # Respond with an empty payload as per the OCPP 1.6 specification.
        return call_result.MeterValuesPayload()

    @on(Action.StartTransaction)
    async def on_start_transaction(
        self, connector_id: int, id_tag: str, timestamp: str, meter_start: int, **kwargs
    ):
        logging.info(f"StartTransaction received: Connector ID: {connector_id}, "
                     f"ID Tag: {id_tag}, Timestamp: {timestamp}, Meter Start: {meter_start}")
        
        # Normally, you'd perform validation here, such as checking the id_tag in your database.
        # For now, let's assume the transaction is always authorized.
        
        # Send a StartTransactionResponse with a transaction ID and status.
        return call_result.StartTransactionPayload(
            transaction_id=1,  # This should be a unique ID, typically generated by your system
            id_tag_info={
                "status": datatypes.IdTagInfo.accepted,
                "expiryDate": (datetime.utcnow() + timedelta(days=365)).isoformat() + "Z",
            }
        )






async def send_default_tx_profile(cp):
    # Define the charging schedule
    schedule = {
        "charging_rate_unit": "W",  # Can be 'W' (Watts) or 'A' (Amperes)
        "charging_schedule_period": [
            {
                "start_period": 0,  # Start immediately
                "limit": 5000,  # Limit to 5 kW
                "number_phases": 1  # Assuming a 3-phase connection
            },
            {
                "start_period": 3600,  # After 1 hour
                "limit": 3000,  # Reduce to 3 kW
                "number_phases": 1
            }
        ]
    }

    # Define the charging profile
    charging_profile = {
        "charging_profile_id": 1,
        "transaction_id": 0,  # Transaction ID 0 for default profiles
        "stack_level": 0,  # Priority level; 0 is the highest priority
        "charging_profile_purpose": ChargingProfilePurposeType.TxDefaultProfile,
        "charging_profile_kind": ChargingProfileKindType.Absolute,
        "valid_from": datetime.utcnow().isoformat() + "Z",
        "valid_to": (datetime.utcnow() + timedelta(days=365)).isoformat() + "Z",  # Valid for 1 year
        "charging_schedule": schedule,
    }

    # Create the SetChargingProfile request
    request = call.SetChargingProfilePayload(
        connector_id=1,  # Assuming connector 1; adjust if necessary
        cs_charging_profiles=charging_profile
    )

    try:
        # Send the SetChargingProfile request and wait for the response
        timeout_seconds = 120
        response = await asyncio.wait_for(cp.call(request), timeout=timeout_seconds)

        # Check the result
        if response.status == "Accepted":
            logging.info("DefaultTx charging profile successfully set.")
        else:
            logging.error(f"Failed to set DefaultTx charging profile: {response.status}")
    except asyncio.TimeoutError:
        logging.error("Timed out waiting for the SetChargingProfile response.")


async def send_get_configuration_command(cp, keys=None):
    """
    Sends a GetConfiguration command to the given charge point.
    
    Parameters:
    cp (ChargePoint): An instance of the ChargePoint class representing the charger.
    keys (list): Optional list of configuration keys to retrieve. If None, all keys will be retrieved.
    """
    # Create the GetConfiguration request
    get_configuration_request = call.GetConfigurationPayload()
    
    try:
        # Send the GetConfiguration request and wait for the response
        timeout_seconds = 120
        response = await asyncio.wait_for(cp.call(get_configuration_request), timeout=timeout_seconds)
        
        # Now response is awaited, and we can handle the returned configuration data
        if response.configuration_key:
            logging.info("Received configuration keys:")
            for config in response.configuration_key:
                logging.info(f"Key: {config['key']}, Value: {config.get('value', 'Not set')}, Readonly: {config['readonly']}")
        else:
            logging.warning("No configuration keys were returned.")
            
        if response.unknown_key:
            logging.warning("The following keys were not recognized:")
            for key in response.unknown_key:
                logging.warning(f"Unknown key: {key}")
    except asyncio.TimeoutError:
        logging.error("Timed out waiting for the GetConfiguration response.")
        

async def on_connect(websocket, path):
    """ For every new charge point that connects, create a ChargePoint instance
    and start listening for messages.

    """
    print('in')
    charge_point_id = path.strip('/')
    cp = MyChargePoint(charge_point_id, websocket)

    await cp.start()
   

async def main():
   server = await websockets.serve(
      on_connect,
      '0.0.0.0',
      9000,
      subprotocols=['ocpp1.6']
   )
    
#    logging.info("Server Started listening to new connections...")
   print('Waiting for new connections...')
   await server.wait_closed()


if __name__ == '__main__':
   asyncio.run(main())



# import asyncio
# import websockets

# async def on_connect(websocket, path):
#     try:
#         requested_protocols = websocket.request_headers['Sec-WebSocket-Protocol']
#         print(f"Requested protocols: {requested_protocols}")
#     except KeyError:
#         print("Client hasn't requested any subprotocol. Proceeding without subprotocol.")

#     if websocket.subprotocol:
#         print(f"Protocols Matched: {websocket.subprotocol}")
#     else:
#         print(f"Proceeding without a matched subprotocol.")
    
#     await websocket.send('Connection made successfully.')
#     print(f'Charge point {path} connected')

# async def main():
#     server = await websockets.serve(
#         on_connect,
#         '0.0.0.0',  # Listen on all network interfaces
#         9000,       # Port number
#         subprotocols=['ocpp1.6']
#     )
#     print("WebSocket Server Started on port 9000")
#     await server.wait_closed()

# if __name__ == '__main__':
#     asyncio.run(main())


# import asyncio
# import logging
# from datetime import datetime

# try:
#     import websockets
# except ModuleNotFoundError:
#     print("This example relies on the 'websockets' package.")
#     print("Please install it by running: ")
#     print()
#     print(" $ pip install websockets")
#     import sys

#     sys.exit(1)

# from ocpp.routing import on
# from ocpp.v16 import ChargePoint as cp
# from ocpp.v16 import call_result
# from ocpp.v16.enums import Action, RegistrationStatus

# logging.basicConfig(level=logging.INFO)


# class ChargePoint(cp):
#     @on(Action.BootNotification)
#     def on_boot_notification(
#         self, charge_point_vendor: str, charge_point_model: str, **kwargs
#     ):
#         return call_result.BootNotificationPayload(
#             current_time=datetime.utcnow().isoformat(),
#             interval=10,
#             status=RegistrationStatus.accepted,
#         )


# async def on_connect(websocket, path):
#     """For every new charge point that connects, create a ChargePoint
#     instance and start listening for messages.
#     """
#     try:
#         requested_protocols = websocket.request_headers["Sec-WebSocket-Protocol"]
#     except KeyError:
#         logging.error("Client hasn't requested any Subprotocol. Closing Connection")
#         return await websocket.close()
#     if websocket.subprotocol:
#         logging.info("Protocols Matched: %s", websocket.subprotocol)
#     else:
#         # In the websockets lib if no subprotocols are supported by the
#         # client and the server, it proceeds without a subprotocol,
#         # so we have to manually close the connection.
#         logging.warning(
#             "Protocols Mismatched | Expected Subprotocols: %s,"
#             " but client supports  %s | Closing connection",
#             websocket.available_subprotocols,
#             requested_protocols,
#         )
#         return await websocket.close()

#     charge_point_id = path.strip("/")
#     cp = ChargePoint(charge_point_id, websocket)

#     await cp.start()


# async def main():
#     server = await websockets.serve(
#         on_connect, "0.0.0.0", 9000, subprotocols=["ocpp1.6"]
#     )

#     logging.info("Server Started listening to new connections...")
#     await server.wait_closed()


# if __name__ == "__main__":
#     # asyncio.run() is used when running this example with Python >= 3.7v
#     asyncio.run(main())